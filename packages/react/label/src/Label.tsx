import * as React from 'react';
import { useComposedRefs } from '@radix-ui/react-compose-refs';
import { Primitive } from '@radix-ui/react-primitive';
import { useId } from '@radix-ui/react-id';

import type * as Radix from '@radix-ui/react-primitive';

/* -------------------------------------------------------------------------------------------------
 * Label
 * -----------------------------------------------------------------------------------------------*/

const NAME = 'Label';

type LabelContextValue = { id: string; onControlChange(control: HTMLElement | null): void };
const LabelContext = React.createContext<LabelContextValue | undefined>(undefined);

type LabelElement = React.ElementRef<typeof Primitive.span>;
type PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;
interface LabelProps extends PrimitiveSpanProps {
  htmlFor?: string;
}

const Label = React.forwardRef<LabelElement, LabelProps>((props, forwardedRef) => {
  const { htmlFor, id: idProp, ...labelProps } = props;
  const [control, setControl] = React.useState<HTMLElement | null>(null);
  const labelRef = React.useRef<HTMLSpanElement>(null);
  const ref = useComposedRefs(forwardedRef, labelRef);
  const id = useId(idProp);

  React.useEffect(() => {
    if (htmlFor) {
      const element = document.getElementById(htmlFor);
      const label = labelRef.current;
      if (label && element) {
        const getAriaLabel = () => element.getAttribute('aria-labelledby');
        const ariaLabelledBy = [getAriaLabel(), id].filter(Boolean).join(' ');
        element.setAttribute('aria-labelledby', ariaLabelledBy);
        setControl(element);
        return () => {
          /**
           * We get the latest attribute value because at the time that this cleanup fires,
           * the values from the closure may have changed.
           */
          const ariaLabelledBy = getAriaLabel()?.replace(id, '');
          if (ariaLabelledBy === '') {
            element.removeAttribute('aria-labelledby');
          } else if (ariaLabelledBy) {
            element.setAttribute('aria-labelledby', ariaLabelledBy);
          }
        };
      }
    }
  }, [id, htmlFor]);

  return (
    <LabelContext.Provider
      value={React.useMemo(() => ({ id, ref: labelRef, onControlChange: setControl }), [id])}
    >
      <Primitive.span
        role="label"
        id={id}
        {...labelProps}
        ref={ref}
        onMouseDown={(event) => {
          props.onMouseDown?.(event);
          // prevent text selection when double clicking label
          if (!event.defaultPrevented && event.detail > 1) event.preventDefault();
        }}
        onClick={(event) => {
          props.onClick?.(event);
          if (!control || event.defaultPrevented) return;
          const isClickingControl = control.contains(event.target as Node);
          // Ensure event was generated by a user action
          // https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted
          const isUserClick = event.isTrusted === true;
          /**
           * When a label is wrapped around the control it labels, we trigger the appropriate events
           * on the control when the label is clicked. We do nothing if the user is already clicking the
           * control inside the label.
           */
          if (!isClickingControl && isUserClick) {
            control.click();
            control.focus();
          }
        }}
      />
    </LabelContext.Provider>
  );
});

Label.displayName = NAME;

/* -----------------------------------------------------------------------------------------------*/

const useLabelContext = (element?: HTMLElement | null) => {
  const context = React.useContext(LabelContext);
  const { onControlChange } = context || {};

  React.useEffect(() => {
    if (element) onControlChange?.(element);
  }, [element, onControlChange]);

  return context?.id;
};

const Root = Label;

export {
  Label,
  //
  Root,
  //
  useLabelContext,
};
export type { LabelProps };
